  <!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>RSpec::Mocks - RSpec - Ruby | Cheats by Kematzy</title>

    <link rel="stylesheet" href="../../assets/css/styles.css">
    <!-- <link rel="stylesheet" href="../../assets/css/-pygment_trac.css"> -->
    <script src="../../assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>


  <body>
    <div id="page" class="container">

      <nav id="header" class="navbar navbar-default">
  <div class="container-fluid row">

    <div class="navbar-header col-md-6">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <div class="navbar-brand">
        <h1><a href="/">Cheats by Kematzy</a></h1>
        <p>A personal collection of Cheatsheets</p>
      </div>
    </div>

    <!-- Collect the nav links, forms, and other content for toggling -->
    <div class="collapse navbar-collapse col-md-6" id="header-nav">
      <ul class="nav navbar-nav">
      
        
          
        <li class="">
          <a href="/index.html" title="back to the homepage">Home</a>
        </li>
        
        
          
        <li class="">
          <a href="/toc.html" title="full table of contents for this website">Table of Contents</a>
        </li>
        
        
          
        <li class="">
          <a href="/about.html" title="find out more information about this website">About</a>
        </li>
        
      </ul>
    </div><!-- /.navbar-collapse -->
  </div><!-- /.container-fluid -->
</nav>


      


<div id="breadcrumbs" class="row">
  <div class="col-md-12">
    <ol class="breadcrumb">
      <li><a href="/">Home</a></li>
      
        
        <li><a href="/ruby/">Ruby</a></li>
      
        
        <li><a href="/ruby/rspec/">Rspec</a></li>
      
        
        <li><a href="/ruby/rspec/rspec-mocks.html">Rspec-mocks</a></li>
      
    </ol>
  </div>
</div>


      <div id="page-contents" class="row">

        <div class="col-md-12">
          <h1 id="ruby-rspec-rspec-mocks">Ruby / RSpec / RSpec::Mocks</h1>

<hr>

<div id="toc"></div>

<hr>

<p><a href="https://github.com/rspec/rspec-mocks">Github Repo</a></p>

<h2 id="introduction">Introduction</h2>

<p><code>rspec-mocks</code> is a test-double framework for <a href="https://github.com/rspec/rspec/">rspec</a> with support for method stubs,
fakes, and message expectations on generated test-doubles and real objects alike.</p>

<h2 id="installation">Installation</h2>
<div class="highlight"><pre><code class="language-bash" data-lang="bash">gem install rspec       # for rspec-core, rspec-expectations, rspec-mocks
gem install rspec-mocks # for rspec-mocks only
</code></pre></div>
<p>Want to run against the <code>master</code> branch? You&#39;ll need to include the dependent RSpec repos as well. Add the following to your <code>Gemfile</code>:</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby">%w[rspec-core rspec-expectations rspec-mocks rspec-support].each do |lib|
  gem lib, :git =&gt; &quot;git://github.com/rspec/#{lib}.git&quot;, :branch =&gt; &#39;master&#39;
end
</code></pre></div>
<h2 id="test-doubles">Test Doubles</h2>

<p>A test double is an object that stands in for another object in your system during a code example. Use the <code>double</code> method, passing in an optional identifier, to create one:</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby">book = double(&quot;book&quot;)
</code></pre></div>
<p>Most of the time you will want some confidence that your doubles resemble an existing object in your system. Verifying doubles are provided for this purpose. If the existing object is available, they will prevent you from adding stubs and expectations for methods that do not exist or that have an invalid number of parameters.</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby">book = instance_double(&quot;Book&quot;, :pages =&gt; 250)
</code></pre></div>
<p>Verifying doubles have some clever tricks to enable you to both test in isolation without your dependencies loaded while still being able to validate them against real objects. More detail is available in <a href="https://github.com/rspec/rspec-mocks/blob/master/features/verifying_doubles">their documentation</a>.</p>

<p>Verifying doubles can also accept custom identifiers, just like double(), e.g.:</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby">books = []
books &lt;&lt; instance_double(&quot;Book&quot;, :rspec_book, :pages =&gt; 250)
books &lt;&lt; instance_double(&quot;Book&quot;, &quot;(Untitled)&quot;, :pages =&gt; 5000)

puts books.inspect # with names, it&#39;s clearer which were actually added
</code></pre></div>
<h2 id="method-stubs">Method Stubs</h2>

<p>A method stub is an implementation that returns a pre-determined value.  Method stubs can be declared on test doubles or real objects using the same syntax. </p>

<p><code>rspec-mocks</code> supports <strong>3 forms for declaring method stubs</strong>:</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"> # 1).
allow(book).to receive(:title) { &quot;The RSpec Book&quot; }
 # 2).
allow(book).to receive(:title).and_return(&quot;The RSpec Book&quot;)
 # 3).
allow(book).to receive_messages(
    :title =&gt; &quot;The RSpec Book&quot;,
    :subtitle =&gt; &quot;Behaviour-Driven Development with RSpec, Cucumber, and Friends&quot;)
</code></pre></div>
<p>You can also use this shortcut, which creates a test double and declares a method stub in one statement:</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby">book = double(&quot;book&quot;, :title =&gt; &quot;The RSpec Book&quot;)
</code></pre></div>
<p>The first argument is a name, which is used for documentation and appears in failure messages. If you don&#39;t care about the name, you can leave it out, making the combined instantiation/stub declaration very terse:</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby">double(:foo =&gt; &#39;bar&#39;)
</code></pre></div>
<p>This is particularly nice when providing a list of test doubles to a method that iterates through them:</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby">order.calculate_total_price(double(:price =&gt; 1.99), double(:price =&gt; 2.99))
</code></pre></div>
<h2 id="consecutive-return-values">Consecutive return values</h2>

<p>When a stub might be invoked more than once, you can provide additional arguments to <code>and_return</code>.  The invocations cycle through the list. The last value is returned for any subsequent invocations:</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby">allow(die).to receive(:roll).and_return(1, 2, 3)
die.roll # =&gt; 1
die.roll # =&gt; 2
die.roll # =&gt; 3
die.roll # =&gt; 3
die.roll # =&gt; 3
</code></pre></div>
<p>To return an array in a single invocation, declare an array:</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby">allow(team).to receive(:players).and_return([double(:name =&gt; &quot;David&quot;)])
</code></pre></div>
<h2 id="message-expectations">Message Expectations</h2>

<p>A message expectation is an expectation that the test double will receive a message some time before the example ends. If the message is received, the expectation is satisfied. If not, the example fails.</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby">validator = double(&quot;validator&quot;)
expect(validator).to receive(:validate) { &quot;02134&quot; }
zipcode = Zipcode.new(&quot;02134&quot;, validator)
zipcode.valid?
</code></pre></div>
<h2 id="test-spies">Test Spies</h2>

<p>Verifies the given object received the expected message during the course of the test. For a message to be verified, the given object must be setup to spy on it, either by having it explicitly stubbed or by being a null object double (e.g. <code>double(...).as_null_object</code>). Convenience methods are provided to easily create null object doubles for this purpose:</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby">spy(&quot;invitation&quot;) # =&gt; same as `double(&quot;invitation&quot;).as_null_object`
instance_spy(&quot;Invitation&quot;) # =&gt; same as `instance_double(&quot;Invitation&quot;).as_null_object`
class_spy(&quot;Invitation&quot;) # =&gt; same as `class_double(&quot;Invitation&quot;).as_null_object`
object_spy(&quot;Invitation&quot;) # =&gt; same as `object_double(&quot;Invitation&quot;).as_null_object`
</code></pre></div>
<p>Verifying messages received in this way implements the Test Spy pattern.</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby">invitation = spy(&#39;invitation&#39;)

user.accept_invitation(invitation)

expect(invitation).to have_received(:accept)

 # You can also use other common message expectations. For example:
expect(invitation).to have_received(:accept).with(mailer)
expect(invitation).to have_received(:accept).twice
expect(invitation).to_not have_received(:accept).with(mailer)

 # One can specify a return value on the spy the same way one would a double.
invitation = spy(&#39;invitation&#39;, :accept =&gt; true)
expect(invitation).to have_received(:accept).with(mailer)
expect(invitation.accept).to eq(true)
</code></pre></div>
<p>Note that <code>have_received(...).with(...)</code> is unable to work properly when passed arguments are mutated after the spy records the received message. </p>

<p>For example, this does not work properly:</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby">greeter = spy(&quot;greeter&quot;)

message = &quot;Hello&quot;
greeter.greet_with(message)
message &lt;&lt; &quot;, World&quot;

expect(greeter).to have_received(:greet_with).with(&quot;Hello&quot;)
</code></pre></div>
<h2 id="nomenclature">Nomenclature</h2>

<h3 id="mock-objects-and-test-stubs">Mock Objects and Test Stubs</h3>

<p>The names Mock Object and Test Stub suggest specialized Test Doubles.  i.e. a Test Stub is a Test Double that only supports method stubs, and a Mock Object is a Test Double that supports message expectations and method stubs.</p>

<p>There is a lot of overlapping nomenclature here, and there are many variations of these patterns (fakes, spies, etc). Keep in mind that most of the time we&#39;re talking about method-level concepts that are variations of method stubs and message expectations, and we&#39;re applying to them to <em>one</em> generic kind of object: a Test Double.</p>

<h3 id="test-specific-extension">Test-Specific Extension</h3>

<p>a.k.a. Partial Double, a Test-Specific Extension is an extension of a real object in a system that is instrumented with test-double like behaviour in the context of a test. This technique is very common in Ruby because we often see class objects acting as global namespaces for methods. </p>

<p>For example, in Rails:</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby">person = double(&quot;person&quot;)
allow(Person).to receive(:find) { person }
</code></pre></div>
<p>In this case we&#39;re instrumenting Person to return the person object we&#39;ve defined whenever it receives the <code>find</code> message. We can also set a message expectation so that the example fails if <code>find</code> is not called:</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby">person = double(&quot;person&quot;)
expect(Person).to receive(:find) { person }
</code></pre></div>
<p>RSpec replaces the method we&#39;re stubbing or mocking with its own test-double-like method. At the end of the example, RSpec verifies any message expectations, and then restores the original methods.</p>

<h2 id="expecting-arguments">Expecting Arguments</h2>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby">expect(double).to receive(:msg).with(*args)
expect(double).to_not receive(:msg).with(*args)
</code></pre></div>
<p>You can set multiple expectations for the same message if you need to:</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby">expect(double).to receive(:msg).with(&quot;A&quot;, 1, 3)
expect(double).to receive(:msg).with(&quot;B&quot;, 2, 4)
</code></pre></div>
<h2 id="argument-matchers">Argument Matchers</h2>

<p>Arguments that are passed to <code>with</code> are compared with actual arguments received using <code>==</code>. In cases in which you want to specify things about the arguments rather than the arguments themselves, you can use any of the matchers that ship with <a href="rspec-expectations.html">rspec-expectations</a>. They don&#39;t all make syntactic sense (they were primarily designed for use with <code>RSpec::Expectations</code>), but you are free to create your own custom <code>RSpec::Matchers</code>.</p>

<p><code>rspec-mocks</code> also adds some keyword Symbols that you can use to specify certain kinds of arguments:</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby">expect(double).to receive(:msg).with(no_args)
expect(double).to receive(:msg).with(any_args)

expect(double).to receive(:msg).with(1, any_args) # any args acts like an arg splat and can go anywhere
expect(double).to receive(:msg).with(1, kind_of(Numeric), &quot;b&quot;) #2nd argument can be any kind of Numeric
expect(double).to receive(:msg).with(1, boolean(), &quot;b&quot;) #2nd argument can be true or false
expect(double).to receive(:msg).with(1, /abc/, &quot;b&quot;) #2nd argument can be any String matching the submitted Regexp
expect(double).to receive(:msg).with(1, anything(), &quot;b&quot;) #2nd argument can be anything at all
expect(double).to receive(:msg).with(1, duck_type(:abs, :div), &quot;b&quot;) #2nd argument can be object that responds to #abs and #div
expect(double).to receive(:msg).with(hash_including(:a =&gt; 5)) # first arg is a hash with a: 5 as one of the key-values
expect(double).to receive(:msg).with(array_including(5)) # first arg is an array with 5 as one of the key-values
expect(double).to receive(:msg).with(hash_excluding(:a =&gt; 5)) # first arg is a hash without a: 5 as one of the key-values
</code></pre></div>
<h2 id="receive-counts">Receive Counts</h2>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby">expect(double).to receive(:msg).once
expect(double).to receive(:msg).twice
expect(double).to receive(:msg).exactly(n).times
expect(double).to receive(:msg).at_least(:once)
expect(double).to receive(:msg).at_least(:twice)
expect(double).to receive(:msg).at_least(n).times
expect(double).to receive(:msg).at_most(:once)
expect(double).to receive(:msg).at_most(:twice)
expect(double).to receive(:msg).at_most(n).times
</code></pre></div>
<h2 id="ordering">Ordering</h2>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby">expect(double).to receive(:msg).ordered
expect(double).to receive(:other_msg).ordered
  # This will fail if the messages are received out of order
</code></pre></div>
<p>This can include the same message with different arguments:</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby">expect(double).to receive(:msg).with(&quot;A&quot;, 1, 3).ordered
expect(double).to receive(:msg).with(&quot;B&quot;, 2, 4).ordered
</code></pre></div>
<h2 id="setting-responses">Setting Responses</h2>

<p>Whether you are setting a message expectation or a method stub, you can tell the object precisely how to respond. The most generic way is to pass a block to <code>receive</code>:</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby">expect(double).to receive(:msg) { value }
</code></pre></div>
<p>When the double receives the <code>msg</code> message, it evaluates the block and returns the result.</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby">expect(double).to receive(:msg).and_return(value)
expect(double).to receive(:msg).exactly(3).times.and_return(value1, value2, value3)
  # returns value1 the first time, value2 the second, etc
expect(double).to receive(:msg).and_raise(error)
  # error can be an instantiated object or a class
  # if it is a class, it must be instantiable with no args
expect(double).to receive(:msg).and_throw(:msg)
expect(double).to receive(:msg).and_yield(values, to, yield)
expect(double).to receive(:msg).and_yield(values, to, yield).and_yield(some, other, values, this, time)
  # for methods that yield to a block multiple times
</code></pre></div>
<p>Any of these responses can be applied to a stub as well</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby">allow(double).to receive(:msg).and_return(value)
allow(double).to receive(:msg).and_return(value1, value2, value3)
allow(double).to receive(:msg).and_raise(error)
allow(double).to receive(:msg).and_throw(:msg)
allow(double).to receive(:msg).and_yield(values, to, yield)
allow(double).to receive(:msg).and_yield(values, to, yield).and_yield(some, other, values, this, time)
</code></pre></div>
<h2 id="arbitrary-handling">Arbitrary Handling</h2>

<p>Once in a while you&#39;ll find that the available expectations don&#39;t solve the particular problem you are trying to solve. Imagine that you expect the message to come with an Array argument that has a specific length, but you don&#39;t care what is in it. You could do this:</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby">expect(double).to receive(:msg) do |arg|
  expect(arg.size).to eq 7
end
</code></pre></div>
<p>If the method being stubbed itself takes a block, and you need to yield to it
in some special way, you can use this:</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby">expect(double).to receive(:msg) do |&amp;arg|
  begin
    arg.call
  ensure
    # cleanup
  end
end
</code></pre></div>
<h2 id="delegating-to-the-original-implementation">Delegating to the Original Implementation</h2>

<p>When working with a partial mock object, you may occasionally want to set a message expectation without interfering with how the object responds to the message. You can use <code>and_call_original</code> to achieve this:</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby">expect(Person).to receive(:find).and_call_original
Person.find # =&gt; executes the original find method and returns the result
</code></pre></div>
<h2 id="combining-expectation-details">Combining Expectation Details</h2>

<p>Combining the message name with specific arguments, receive counts and responses you can get quite a bit of detail in your expectations:</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby">expect(double).to receive(:&lt;&lt;).with(&quot;illegal value&quot;).once.and_raise(ArgumentError)
</code></pre></div>
<p>While this is a good thing when you really need it, you probably don&#39;t really need it! Take care to specify only the things that matter to the behaviour of your code.</p>

<h2 id="stubbing-and-hiding-constants">Stubbing and Hiding Constants</h2>

<p>See the <a href="https://github.com/rspec/rspec-mocks/blob/master/features/mutating_constants/README.md">mutating constants README</a>
for info on this feature.</p>

<h2 id="use-before-example-not-before-context">Use <code>before(:example)</code>, not <code>before(:context)</code></h2>

<p>Stubs in <code>before(:context)</code> are not supported. The reason is that all stubs and mocks get cleared out after each example, so any stub that is set in <code>before(:context)</code> would work in the first example that happens to run in that group, but not for any others.</p>

<p>Instead of <code>before(:context)</code>, use <code>before(:example)</code>.</p>

<h2 id="settings-mocks-or-stubs-on-any-instance-of-a-class">Settings mocks or stubs on any instance of a class</h2>

<p>rspec-mocks provides two methods, <code>allow_any_instance_of</code> and <code>expect_any_instance_of</code>, that will allow you to stub or mock any instance of a class. They are used in place of <code>allow</code> or <code>expect</code>:</p>
<div class="highlight"><pre><code class="language-ruby" data-lang="ruby">allow_any_instance_of(Widget).to receive(:name).and_return(&quot;Wibble&quot;)
expect_any_instance_of(Widget).to receive(:name).and_return(&quot;Wobble&quot;)
</code></pre></div>
<p>These methods add the appropriate stub or expectation to all instances of <code>Widget</code>.</p>

<p>This feature is sometimes useful when working with legacy code, though in general we discourage its use for a number of reasons:</p>

<ul>
<li><p>The <code>rspec-mocks</code> API is designed for individual object instances, but this
feature operates on entire classes of objects. As a result there are some
semantically confusing edge cases. For example in
<code>expect_any_instance_of(Widget).to receive(:name).twice</code> it isn&#39;t clear
whether each specific instance is expected to receive <code>name</code> twice, or if two
receives total are expected. (It&#39;s the former.)</p></li>
<li><p>Using this feature is often a design smell. It may be
that your test is trying to do too much or that the object under test is too
complex.</p></li>
<li><p>It is the most complicated feature of <code>rspec-mocks</code>, and has historically
received the most bug reports. (None of the core team actively use it,
which doesn&#39;t help.)</p></li>
</ul>

<h2 id="further-reading">Further Reading</h2>

<p>There are many different viewpoints about the meaning of mocks and stubs. If
you are interested in learning more, here is some recommended reading:</p>

<ul>
<li><a href="http://www.mockobjects.com/">Mock Objects</a></li>
<li><a href="http://stalatest.googlecode.com/svn/trunk/Literatur/mockobjects.pdf">Endo-Testing</a></li>
<li><a href="http://jmock.org/oopsla2004.pdf">Mock Roles, Not Objects</a></li>
<li><a href="http://www.martinfowler.com/bliki/TestDouble.html">Test Double</a></li>
<li><a href="http://xunitpatterns.com/Test%20Double%20Patterns.html">Test Double Patterns</a></li>
<li><a href="http://www.martinfowler.com/articles/mocksArentStubs.html">Mocks aren&#39;t stubs</a></li>
</ul>

<hr>

<h2 id="see-also">See Also</h2>

<ul>
<li><a href="/ruby/rspec/index.html">RSpec</a> or <a href="http://github.com/rspec/rspec">http://github.com/rspec/rspec</a></li>
<li><a href="/ruby/rspec/rspec-core.html">RSpec::Core</a> or <a href="http://github.com/rspec/rspec-core">http://github.com/rspec/rspec-core</a></li>
<li><a href="/ruby/rspec/rspec-expectations.html">RSpec::Expectations</a> or <a href="http://github.com/rspec/rspec-expectations">http://github.com/rspec/rspec-expectations</a></li>
<li><a href="/ruby/rspec/rspec-mocks.html">RSpec::Mocks</a> or <a href="http://github.com/rspec/rspec-mocks">http://github.com/rspec/rspec-mocks</a></li>
<li><a href="/ruby/rspec/rspec-collection_matchers.html">RSpec::CollectionMatchers</a> or <a href="https://github.com/rspec/rspec-collection_matchers">http://github.com/rspec/rspec-collection_matchers</a></li>
<li><a href="/ruby/rspec/rspec-html-matchers.html">RSpec::HMTMLMatchers</a> or <a href="https://github.com/kucaahbe/rspec-html-matchers">https://github.com/kucaahbe/rspec-html-matchers</a></li>
</ul>

        </div>

      </div>

      <div id="footer" class="row">
  <div class="col-md-12">
    <p>Project maintained by <a href="https://github.com/kematzy">kematzy</a></p>
    <p>Hosted on GitHub Pages &mdash; Design based upon a theme created by <a href="https://github.com/orderedlist">orderedlist</a></p>
  </div>
</div>

      
    </div>

    <!--[if !IE]><script>fixScale(document);</script><![endif]-->
    <script src="../../assets/js/jquery-2.1.3.min.js"></script>
    <script src="../../assets/js/bootstrap.min.js"></script>
    <script src="../../assets/js/highlight.pack.js"></script>
    <script src="../../assets/js/toc.js"></script>
    <script type="text/javascript">
      hljs.initHighlightingOnLoad();
      $(document).ready(function() {
        $('#toc').toc({ listType: 'ul',  headers: 'h2, h3', showEffect: 'slideDown' });
        // $('.clickable-header').click(function({
        //
        // }));
      });
    </script>
  </body>
</html>
